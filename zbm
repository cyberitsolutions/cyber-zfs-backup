#!/usr/bin/python

import cherrypy
from cherrypy import expose, tools, url

import os
import time
from datetime import datetime, timedelta
import timediff
import string
import re

import cgi
import html
from html import head, body, title

import chroot

# The authentication module.
from auth import AuthController, require, member_of, name_is

# Filesystem-browsing functionality.
import browse

local_dir = os.path.join(os.getcwd(), os.path.dirname(__file__))

# Pages.

def page(title, content):
    return html.html(head(
            html.title(title)
            + html.link(att='type="text/css" rel="stylesheet" href="/static/zbm.css"') # <link rel="stylesheet" href="/trac/css/trac.css" type="text/css" />
            + html.link(att='type="text/css" rel="stylesheet" href="/static/tablesorter.css"')
            + html.script(att='type="text/javascript" src="/static/jquery-1.2.6.min.js"')
            + html.script(att='type="text/javascript" src="/static/jquery.tablesorter.min.js"')
            + html.script(att='type="text/javascript" src="/static/zbm.js"')
            )
        + body(
            html.div("This is the header", att='class="header"')
            + html.div(content, att='id="main"')
            + html.div("This is the footer", att='class="footer"')))

# File size stuff.
file_size_class = [
    (1024, 'B'),
    (1024**2, 'KB'),
    (1024**3, 'MB'),
    (1024**4, 'GB'),
    (1024**5, 'TB')
]

def filesize_exp(size):
    s = file_size_class[0]
    if size < s[0]:
        return str(size)

    s = file_size_class[-1]
    if not size < s[0]:
        return "%0.1f%s" % ( float(size)/(s[0]/1024), s[1] )

    for s in file_size_class[1:]:
        if size < s[0]:
            return "%0.1f%s" % ( float(size)/(s[0]/1024), s[1] )

# Given size in bytes, return suitable HTML expression.
def filesize_html(size):
    return html.span(filesize_exp(size), att='value="%s"' % ( size ))

def filename_html(filespec):
    f = filespec
    fname = f.name
    if f.type == 'dir':
        return html.a(fname, att='href="/browse?path=%s"' % ( cgi.escape(f.path, quote=True) ))
    return fname

def split_path(pathname):
    if pathname == '/':
        return ['/']
    if pathname == '':
        return []
    (basepath, basename) = os.path.split(pathname)

    sp = split_path(basepath)
    if basename != '':
        sp.append(basename)
    return sp


def pathname_dirlink(pathname):
    """
    Takes a path string and return a string where each directory
    name is a link to that directory, eg.:

    "/etc/" => '<a href="/browse?path=/">&nbsp;/</a><a href="/browse?path=/etc">etc/</a>'

    The trailing / should be included in the link text.

    Note that there is no validation that it's a real path.
    """
    if pathname == '/':
        return html.a(html.b("/"), att='href="/browse?path=/"')

    (basepath, basename) = os.path.split(pathname)
    name_html = html.a(basename + "/", att='class="dirlink" href="/browse?path=%s"' % ( cgi.escape(pathname, quote=True) ))
    if basepath == '':
        return name_html
    return pathname_dirlink(basepath) + name_html

def tr_filespec(filespec, revolver=None):
    f = filespec

    tr_attr = ""
    if not revolver is None:
        tr_attr = "class='%s'" % ( revolver.state() )

    lmt = time.localtime(f.mtime)
    time_exp = time.strftime('%Y-%m-%d %H:%M:%S', lmt)

    filename_ext = ''
    m = re.search(r'^[^.].*\.([^.]+)$', f.name)
    if m:
        filename_ext = string.lower(m.group(1))

    now = datetime.now()
    mtime_dt = datetime(*lmt[:6])
    age_exp = ''
    if mtime_dt < now:
        age_exp = str(timediff.show(now - mtime_dt))

    escaped_path = cgi.escape(f.path, quote=True)
    checkbox_attr = 'name="path:%s" type="checkbox"' % ( escaped_path )
    return html.tr(
        html.td([
            html.input(att=checkbox_attr),
            f.type,
            filesize_html(f.size),
            filename_html(f),
            filename_ext,
            time_exp,
            age_exp]), att=tr_attr)

def can_access_parent(path):
    return not ( path == '/' or path == '' )

class EmptyRevolverError(Exception):
    def __init__(self, value):
        self.value = value
    def __str__(self):
        return repr(self.value)

# Rotates through the values of a given array/tuple.
class Revolver:
    def __init__(self, collection):
        if len(collection) == 0:
            raise EmptyRevolverError("Empty collection supplied to Revolver.")
        self._collection = collection
        self._index = 0

    def state(self):
        rv = self._collection[self._index]
        incremented = self._index + 1
        if incremented < len(self._collection):
            self._index = incremented
        else:
            self._index = 0
        return rv

def dir_box(chrooted_path):
    select_all_checkbox = html.input(att='id="select_all" name="select_all" type="checkbox"')
    dir_header = html.thead(html.tr(html.th([select_all_checkbox, 'Type', 'Size', 'Name', 'Ext', 'Last Modified', 'Age'])))
    dir_contents = browse.get_dir_contents(chrooted_path)

    parent_dir_html = ""
    if not dir_contents[0] is None:
        parent_dir_html = html.p(filename_html(dir_contents[0]))

    revolver = Revolver(('row_odd', 'row_even'))

    dir_contents_html = html.tbody(string.join(map(lambda fs: tr_filespec(fs, revolver), dir_contents[1:])))
    return html.div(parent_dir_html + html.table(dir_header + dir_contents_html, att='class="browsedir tablesorter"'), att='class="browsedir"')


class ZfsBackupManager:
    auth = AuthController()

    def __init__(self, base_path="/"):
        # If an exception is raised here, let it go.
        self.chroot = chroot.Chroot(base_path)

    @expose
    @require()
    def index(self, path="/"):
        return self.browse(path)

    @expose
    @require()
    def browse(self, path="/"):
        error_message = ""
        dir_box_html = ""
        try:
            chrooted_path = self.chroot.chrooted_path(path)
            dir_box_html = dir_box(chrooted_path)
        except chroot.BadChrootPath, e:
            error_message = html.p(html.span(str(e), att='class="error_message"'))

        return page("ZBM - Zfs Backup Manager",
            html.h1("Directory: %s" % ( pathname_dirlink(path) ))
            + error_message
            + html.img(att='src="/static/made_with_cherrypy_small.png" alt="Made with CherryPy"')
            + dir_box_html)

    static = tools.staticdir.handler(section="/static",
            dir=os.path.join(local_dir, "static"))

    @expose
    @require(name_is("joe"))
    def json(self, *args, **kwargs):
        return page("JSON Page", html.h1("This is just the JSON page"))


# Config.

zbm_config = {
    'global' : {
        'server.socket_host': '0.0.0.0',
        'server.socket_port': 8000,
        'server.thread_pool': 10,
        'tools.sessions.on' : True,
        'tools.auth.on' : True
    }
}

app_config = {
    'global' : {
        'tools.staticdir.root' : os.path.join(os.path.abspath('.'), "static")
    },

    # Define the web-app's favicon.
    '/favicon.ico' : {
        'tools.staticfile.on' : True,
        'tools.staticfile.filename' : os.path.join(os.path.abspath('.'), "static/zbm.ico")
    }
}

######################################################################
## 3.0-specific syntax.
cherrypy.config.update(zbm_config)
cherrypy.quickstart(ZfsBackupManager(os.environ['HOME']), config=app_config)

######################################################################
## 3.1-specific syntax.
#cherrypy.config.update(zbm_config)
#cherrypy.tree.mount(ZfsBackupManager(), '/', app_config)
#cherrypy.engine.start()
#cherrypy.engine.block()

