#!/usr/bin/python

import cherrypy
from cherrypy import expose, tools, url

import sys
import os
import time
from datetime import datetime, timedelta
import timediff
import string
import re
import simplejson

import cgi
import html
import auth
import page

import chroot

# Simple database-access functionality.
import db

# ZBM config module.
import zbm_cfg as cfg
import zbm_email

# The authentication module.
from auth import AuthController, require, member_of, name_is

# The restore handler.
import restore_spec

# Filesystem-browsing functionality.
import browse

# Functions for validating fancy user credentials.
import validation

local_dir = os.path.join(os.getcwd(), os.path.dirname(__file__))

# File size stuff.
file_size_class = [
    (1024, 'B'),
    (1024**2, 'KB'),
    (1024**3, 'MB'),
    (1024**4, 'GB'),
    (1024**5, 'TB')
]

def filesize_exp(size):
    s = file_size_class[0]
    if size < s[0]:
        return str(size)

    s = file_size_class[-1]
    if not size < s[0]:
        return "%0.1f%s" % ( float(size)/(s[0]/1024), s[1] )

    for s in file_size_class[1:]:
        if size < s[0]:
            return "%0.1f%s" % ( float(size)/(s[0]/1024), s[1] )

def value_span(expression, value):
    return html.span(expression, att='value="%s"' % ( value ))

# Given size in bytes, return suitable HTML expression.
def filesize_html(size):
    return value_span(filesize_exp(size), size)

def split_path(pathname):
    if pathname == '/':
        return ['/']
    if pathname == '':
        return []
    (basepath, basename) = os.path.split(pathname)

    sp = split_path(basepath)
    if basename != '':
        sp.append(basename)
    return sp


def pathname_dirlink(share, pathname, highlight_share=False, show_all_shares_link=True):
    """
    Takes a path string and return a string where each directory
    name is a link to that directory, eg.:

    "/etc/" => '<a href="/browse?path=/">&nbsp;/</a><a href="/browse?path=/etc">etc/</a>'

    The trailing / should be included in the link text.

    Note that there is no validation that it's a real path.
    """
    escaped_share = cgi.escape(share, quote=True)
    all_shares_link = ""
    if show_all_shares_link:
        all_shares_link = html.a("shares/", att='class="dirlink" href="/backup/browse"')
    if pathname == '/':
        share_link = html.a(escaped_share+"/", att='id="share_name" name="%s" class="dirlink" href="/backup/browse?share=%s&amp;path=/"' % ( escaped_share, escaped_share ))
        if highlight_share:
            return all_shares_link + html.b(share_link)
        return all_shares_link + share_link

    (basepath, basename) = os.path.split(pathname)
    name_html = html.a(basename + "/", att='class="dirlink" href="/backup/browse?share=%s&amp;path=%s"' % ( escaped_share, cgi.escape(pathname, quote=True) ))
    if basepath == '':
        return name_html
    return pathname_dirlink(share, basepath, highlight_share=highlight_share, show_all_shares_link=show_all_shares_link) + name_html

def get_extension(filename):
    filename_ext = ''
    m = re.search(r'^[^.].*\.([^.]+)$', filename)
    if m:
        filename_ext = string.lower(m.group(1))
    return filename_ext

def tr_filespec(rs, file_spec, revolver=None):
    f = file_spec

    tr_attr = ""
    if not revolver is None:
        tr_attr = "class='%s'" % ( revolver.state() )

    lmt = time.localtime(f.mtime)
    time_exp = time.strftime('%Y-%m-%d %H:%M:%S', lmt)

    filename_ext = get_extension(f.name)

    now = datetime.now()
    mtime_dt = datetime(*lmt[:6])
    age_exp = ''
    if mtime_dt < now:
        age_exp = str(timediff.show(now - mtime_dt))

    escaped_path = cgi.escape(f.path, quote=True)
    is_checked = ""
    if rs.is_included(f):
        is_checked = " checked"
        if not rs.is_directly_included(f):
            is_checked += " disabled"

    checkbox_attr = 'class="zbm_select" name="path:%s" type="checkbox"%s' % ( escaped_path, is_checked )
    return html.tr(
        html.td([
            html.input(att=checkbox_attr),
            f.type,
            filesize_html(f.size),
            f.display,
            filename_ext,
            time_exp,
            value_span(age_exp, time_exp)]), att=tr_attr)

def can_access_parent(path):
    return not ( path == '/' or path == '' )

class EmptyRevolverError(Exception):
    def __init__(self, value):
        self.value = value
    def __str__(self):
        return repr(self.value)

# Rotates through the values of a given array/tuple.
class Revolver:
    def __init__(self, collection):
        if len(collection) == 0:
            raise EmptyRevolverError("Empty collection supplied to Revolver.")
        self._collection = collection
        self._index = 0

    def state(self):
        rv = self._collection[self._index]
        incremented = self._index + 1
        if incremented < len(self._collection):
            self._index = incremented
        else:
            self._index = 0
        return rv

def dir_box(rs, share, chrooted_path, page_num, company_name=None):
    dir_filespec = browse.FileSpec(chrooted_path, share, company_name=company_name)
    escaped_share_plus_path = cgi.escape(dir_filespec.share_plus_path, quote=True)
    page_count, dir_contents = browse.get_dir_contents(chrooted_path, share, page_num, company_name=company_name)

    def all_directly_included(rs, fs):
        for f in fs:
            if not rs.is_directly_included(f):
                return False
        return True

    # Check to see if all dir_contents are (directly) included.
    select_all_extra = ""
    if rs.is_included(dir_filespec):
        select_all_extra = " disabled checked"
    elif len(dir_contents) > 1 and all_directly_included(rs, dir_contents[1:]):
        select_all_extra = " checked"

    select_all_checkbox = html.input(att='id="select_all" name="spath:%s" title="Select/deselect all" type="checkbox"%s' % ( escaped_share_plus_path, select_all_extra ))

    dir_header = html.thead(html.tr(html.th([select_all_checkbox, 'Type', 'Size', 'Name', 'Ext', 'Last Modified', 'Age'])))

    parent_dir_html = ""
    if not dir_contents[0] is None:
        parent_dir_html = html.p(dir_contents[0].display)

    revolver = Revolver(('row_odd', 'row_even'))

    dir_contents_html = html.tbody(string.join(map(lambda fs: tr_filespec(rs, fs, revolver), dir_contents[1:])))
    return html.div(parent_dir_html + html.table(dir_header + dir_contents_html, att='class="browsedir tablesorter"'), att='class="browsedir"')

def make_file_spec(company_name, share_name, path):
    """ Returns a FileSpec from a company_name, share_name, path. """
    sp = chroot.build_share_path(company_name, share_name)
    mychroot = chroot.Chroot(sp)
    return browse.FileSpec(mychroot.chrooted_path(path), share_name, company_name=company_name)

def make_file_download_link(filename):
    """ Return a (redirecting) download link for a restore file. """
    return html.a(filename, att='href="/backup/download?file=%s"' % ( cgi.escape(filename, quote=True)))


class ZfsBackupManager:
    auth = AuthController()

    def __init__(self):
        # If an exception is raised here, let it go.
        pass

    @expose
    @require()
    def index(self):
        return self.browse()

    @expose
    @require()
    def show(self, restore_id=None, message=None):
        ( username, _, company_name, _ ) = auth.login_status()

        rs = None
        if restore_id is None:
            rs = restore_spec.RestoreSpec()
            restore_id = rs.restore_id
        else:
            restore_id = int(restore_id)
            rs = restore_spec.RestoreSpec(restore_id)

        ifs_header = html.thead(html.tr(html.th(['', 'Size', 'Name'])))
        # Assemble simple list of the files in given restore.
        revolver = Revolver(('row_odd', 'row_even'));

        def make_checkbox_input(fs):
            escaped_share_plus_path = cgi.escape(fs.share_plus_path, quote=True)
            # Note the prefix of the name attribute's value is
            # "spath", not "path" - because it has to be a
            # share_plus_path expression.
            checkbox_attr = 'class="zbm_select" name="spath:%s" type="checkbox" checked' % ( escaped_share_plus_path )
            return html.input(att=checkbox_attr)

        def ifs_to_row(file_spec):
            """ Returns a HTML link for displaying a share-plus-path expression. """
            tr_attr = "class='%s'" % ( revolver.state() )
            share_name = file_spec.share

            # The file_path we want to use is the *parent* of the
            # file_spec above.
            parent_file_spec = file_spec.get_parent()
            if parent_file_spec is None:
                # This technically should not happen, as we don't
                # provide a way to select an entire share.
                parent_file_spec = file_spec

            parent_file_path = parent_file_spec.path

            escaped_share_name = cgi.escape(share_name, quote=True)
            file_spec_size_span = filesize_html(file_spec.acquire_disk_usage())
            return html.tr(html.td([make_checkbox_input(file_spec), file_spec_size_span,
                    html.span(pathname_dirlink(share_name, parent_file_path, highlight_share=True, show_all_shares_link=False) + cgi.escape(file_spec.basename, quote=True), att='value="%s"' % ( file_spec.share_plus_path )) ]), att=tr_attr)

        included_filespecs = rs.include_set.values()

        restore_display = ""
        if len(included_filespecs) > 0:
            form = html.form(
                html.table(
                    html.tbody(
                        html.tr(
                            html.td([
                                html.input(att='name="cancel_restore" type="submit" value="Empty Cart" title="Wipe out your current set of restore files."'),
                                html.input(att='name="create_tarball" type="submit" value="Create Tarball" title="Create a restore tarball."'),
                                html.input(att='name="create_zipfile" type="submit" value="Create Zipfile" title="Create a restore zipfile."')
                            ]))),
                    att='class="borderless restore_action"'),
                att='name="restore" method="post" action="/backup/action"')

            # Sort them for a more orderly display.
            included_filespecs.sort(lambda a, b: cmp(a.share_plus_path, b.share_plus_path))
            restore_path_rows = string.join([ ifs_to_row(ifs) for ifs in included_filespecs ])
            restore_display = form + html.table(ifs_header + html.tbody(restore_path_rows), att='style="margin-left:10px" class="tablesorter restore_display"')
        else:
            restore_display = html.p("Your current cart is empty.")

        if message is None:
            message = ""
        else:
            message = html.p(message)

        # Okay, let's show some actual *details* about the current
        # restore.
        running_total_size = ''
        if rs.disk_usage_running_total > 0:
            running_total_size = html.p("Running total size is %s." % ( html.span(filesize_exp(rs.disk_usage_running_total), att='class="running_total_size"') ))
        return page.page("Cart",
            html.h1("Cart")
            + message
            + running_total_size 
            + restore_display 
            + self.restore_dir_contents()
            )

    @expose
    @require()
    def browse(self, share=None, path="/", company_name=None, page_num=1):

        companies = auth.get_user_admin_companies()
        # Info from session.
        comp = (cherrypy.session.get(auth.COMPANY_NAME), cherrypy.session.get(auth.COMPANY_FULLNAME))
        # Don't add the logged-in company to the list if it's already there
        if comp not in companies:
            companies.append(comp)
        companies = [x[0] for x in companies if validation.company_exists(x[0])]

        # Okay, how to handle share....?
        if share is None or (company_name and company_name not in companies):
            def prettify(s):
                # Some sort of standard needs to be enforced for share names.
                # At the moment, assuming host:path/to/share
                chunks = s.split(':')
                host = chunks[0]
                if len(chunks) > 1:
                    if chunks[1] in ('.', ''):
                        # Looks like this should be a '/'.
                        path = '/'.join([''] + max(chunks[2:], ['']))
                    elif len(chunks[1]) == 1:
                        # Looks like a Windows drive letter.
                        # Probably need a more robust check.
                        path = "%s:/%s"%(chunks[1], "/".join(chunks[2:]))
                    else:
                        path = "/".join([''] + chunks[1:])
                    # Delimit host and path with an em-dash because : is ugly.
                    return "%s &mdash; %s"%(host, path)
                else:
                    return host
            share_section = ""
            for company_name in companies:
                if len(companies) > 1:
                    share_section += html.h2(company_name)
                available_shares = [ s[0] for s in db.get("select name from shares where company_name = %(company_name)s", vars()) ]
                if auth.user_is_multi_admin():
                    add_href = "&company_name=" + cgi.escape(company_name, quote=True)
                else:
                    add_href = ""
                links = [ html.a(prettify(s), att='href="/backup/browse?share=%s%s"' % ( cgi.escape(s, quote=True), add_href )) for s in available_shares ]
                share_section += html.ul(html.li(links))

            return page.page("Select Share",
                html.h1("Select Share")
                + share_section )
        if not company_name and auth.user_is_multi_admin():
            company_name = companies[0]

        rs = restore_spec.RestoreSpec()
        error_message = ""
        dir_box_html = ""
        try:
            if company_name:
                comp = company_name
            else:
                comp = cherrypy.session.get(auth.COMPANY_NAME)
            # Now we use the company and share names to construct the chroot.
            sp = chroot.build_share_path(comp, share)

            mychroot = chroot.Chroot(sp)
            chrooted_path = mychroot.chrooted_path(path)
            # Supply the share name as well as the chrooted path.
            dir_box_html = dir_box(rs, share, chrooted_path, page_num, company_name=company_name)
        except chroot.BadChrootPath, e:
            error_message = html.p(html.span(str(e), att='class="error_message"'))
        download_link = html.div(html.a("View Cart", att='href="/backup/show"'), att='class="funcright"')
        return page.page("Browse Share",
            download_link
            + html.h1(pathname_dirlink(share, path), att='class="dirlink"')
            + error_message
            + dir_box_html)

    static = tools.staticdir.handler(section="/static",
            dir=os.path.join(local_dir, "static"))

    # Helper for showing the contents of the restore directory.
    def restore_dir_contents(self):
        """ Returns restore directory contents as an unordered list. """
        company_name = cherrypy.session.get(auth.COMPANY_NAME)
        company_restore_dir = os.path.join(cfg.RESTORE_BASE_DIR, company_name)
        contents = os.listdir(company_restore_dir)
        if len(contents):
            # The timestamp will appear after the last '_' in the filename. Sort by that instead of sorting by the restore ID with string comparison.
            contents.sort(key=lambda x: x[x.rindex('_')+1:], reverse=True)
            return html.h3("Available restores:") + \
                html.ul(html.li([ make_file_download_link(filename) + html.nbsp() + "(" + filesize_exp(os.lstat(os.path.join(cfg.RESTORE_BASE_DIR, company_name, filename))[6]) + ")" for filename in contents ]))
        else:
            return ""

    @expose
    @require()
    def download(self, file):
        """ Sends an email and redirects. """
        ( username, full_name, company_name, _ ) = auth.login_status()

        download_url = cfg.RESTORE_BASE_PATH + '/' + company_name + '/' + file

        # Send the email. Quickly now!
        # We need to send this to the user and the company.
        # And also an effective-BCC to NOTIFY_CC_EMAIL_ADDRESS.
        user_email_address = None
        uea = db.get1("select email from users where username = %(username)s", vars())
        if uea is not None:
            user_email_address = uea[0]
        company_email_address = None
        cea = db.get1("select email from companies where name = %(company_name)s", vars())
        db.commit()
        if cea is not None:
            company_email_address = cea[0]

        download_file_path = os.path.join(cfg.RESTORE_BASE_DIR, company_name, file)
        download_file_basename = os.path.basename(download_file_path)
        download_file_size_expression = filesize_exp(os.lstat(download_file_path)[6])

        content_vars = {
            'human_readable_datetime' : str(datetime.now()),
            'download_url' : cfg.RESTORE_BASE_URL + '/' + download_url,
            'username' : username,
            'full_name' : full_name,
            'download_file_size' : download_file_size_expression
        }

        # Okay, now really send the email.
        zbm_email.send_email(cfg.FROM_EMAIL_ADDRESS,
                [user_email_address, company_email_address],
                "Datasafe/R download: %s" % ( download_file_basename ),
                cfg.COMPANY_FILE_DOWNLOAD_TEMPLATE % content_vars,
                actual_addressees=[user_email_address, company_email_address, cfg.NOTIFY_CC_EMAIL_ADDRESS])

        # Raise the redirect.
        cherrypy.request.base = cfg.RESTORE_BASE_URL
        raise cherrypy.HTTPRedirect(download_url)

    @expose
    @require()
    def action(self, **kwargs):
        result = False
        message = None
        rs = restore_spec.RestoreSpec()
        if 'retrieve_restore' in kwargs:
            restore_spec.retrieve_previous_restore()
            message = "Returned to previous cart."
        if 'cancel_restore' in kwargs:
            restore_spec.cancel_current_restore()
            message = "Cart emptied."
        if 'create_tarball' in kwargs:
            ( result, partname ) = restore_spec.create_restore_file(rs, "tar")
            if result:
                link_type = 'tarball'
            else:
                message = "Failed to create tarball: %s" % ( partname )
        if 'create_zipfile' in kwargs:
            ( result, partname ) = restore_spec.create_restore_file(rs, "zip")
            if result:
                link_type = 'zip file'
            else:
                message = "Failed to create zip file: %s" % ( partname )
        # Once a restore is successfully created, clear out the cart
        if result:
            message = "Successfully created %s. Click to download: %s" % ( link_type, make_file_download_link(partname) )
            restore_spec.cancel_current_restore()

        return self.show(message=message)

    @expose
    @require()
    def user(self):
        sections = []
        lstatus = auth.login_status()
        company_name = cherrypy.session.get(auth.COMPANY_NAME)
        username = lstatus[0]

        view_link = html.a("Your shares", att='href="/backup/browse" title="Browse your shares"')

        # Yanked from browse()
        available_shares = [ s[0] for s in db.get("select name from shares where company_name = %(company_name)s", vars()) ]

        links = []
        for share in available_shares:
            snap_path = os.path.abspath(chroot.build_share_path(company_name, share))
            if (os.path.isdir(snap_path)):
                # Try to get the most recent snapshot (assume sensible sorting facility)
                last_snap = "%s/%s" % ( snap_path, sorted(os.listdir(snap_path))[-1] )
                size = db.get1("select apparent_size from filesystem_info where path = %(last_snap)s", vars())[0]
                links.append("%s (%s)" % ( html.a(share, att='href="/backup/browse?share=%s"' % ( cgi.escape(share, quote=True) )), filesize_html(size) ))
            
        share_num = "You have %d shares." % len(links)
        sections.append(html.h2(view_link) + share_num + html.ul(html.li(links)))

        passwd_link = html.a("Change your password", att='href="/backup/password"')
        sections.append(html.h2(passwd_link))

        # TODO: Provide change email facility.

        return page.page("Account " + username,
            html.h1("User account - " + username)
            + "".join(sections))

    def company_combobox(self, name, companies, selected=None, allow_null=True, null_text="&lt;None&gt;", multi=False):
        opts=''
        if allow_null:
            if selected is None or (not isinstance(selected, basestring) and None in selected):
                att = 'selected '
            else:
                att = ''
            opts = html.option(null_text, att + 'value="NULL"')
        for c in companies:
            if selected is not None and (c[0] == selected or (not isinstance(selected, basestring) and c[0] in selected)):
                att = 'selected '
            else:
                att = ''
            opts += html.option(c[1], att + 'value="%s"' % c[0])
        att = 'name="%s"' % name
        if multi:
            att += ' multiple'
        return html.select(opts, att=att)

    def admin_user_table(self, company_name, all_companies):
        """Returns a table of users in the supplied company_name
        company_name should be either a string (company_name) or a tuple (company_name,company_fullname)"""
        c = ''
        if isinstance(company_name, basestring):
            company = (company_name, company_name)
        else:
            company = company_name
        if company_name[0] is None:
            users = db.get("select users.username, full_name, email, users.company_name from users \
                where users.company_name is null \
                order by users.username")
        else:
            c = company[0].replace("'","''")
            users = db.get("select username, full_name, email, company_name from users where company_name = %(c)s order by username", vars())

        def field(i_type, comm, comp, user, value="", extra=""):
            el = ""
            submit = ""
            if value is None:
                value = ""
            elif i_type == "text" and value in [True, False]:
                if value:
                    value = "Yes"
                else:
                    value = "No"

            if comp is None:
                comp = ""

            if i_type == "checkbox":
                if value:
                    checked = "checked"
                else:
                    checked = ""
                el = html.input(att='type="%s" name="value" %s value="true"' % (i_type, checked))
            elif i_type:
                el = html.input(att='type="%s" name="value" value="%s"' % (i_type, value))
            if i_type != "submit":
                    submit = html.input(att='type="submit" value="Set"')

            return html.td(
                html.form(
                    html.input(att='type="hidden" name="user" value="%s"' % user)
                    + html.input(att='type="hidden" name="comp" value="%s"' % comp)
                    + html.input(att='type="hidden" name="comm" value="%s"' % comm)
                    + el
                    + extra
                    + submit
                    , att='class="borderless" action="admin_confirm" method="post"'
                    )
                )

        rows = []
        company_th = ''
        for u in users:
            row = ''
            ## Username ##
            row += html.td(u[0])
            ## Full name ##
            row += field("text", "name", comp=u[3], user=u[0], value=u[1])
            ## Company ##
            if auth.user_is_global_admin():
                company_th = html.th("Company")
                row += field(None, "company", comp=u[3], user=u[0],
                    extra=self.company_combobox('value', all_companies, selected=u[3])
                )
            ## Email ##
            row += field("text", "email", comp=u[3], user=u[0], value=u[2])
            ## Admin ##
            # Only Global admins should be allowed to change other Global admin settings
            if not auth.user_is_global_admin() and auth.user_is_global_admin(u[0]):
                row += html.td("Yes &lt;All&gt;")
            else:
                if auth.user_is_admin(u[0], company_name[0]):
                    checked = "checked"
                else:
                    checked = ""
                extra = ""
                if auth.user_is_multi_admin():
                    my_username = auth.login_status()[0]
                    if auth.user_is_global_admin():
                        my_comps = all_companies
                    else:
                        my_comps = auth.get_user_admin_companies()
                    their_username = u[0]
                    their_comps = [x[0] for x in auth.get_user_admin_companies(their_username, allow_null=True)]
                    extra = self.company_combobox('extra', my_comps
                        , multi=True, selected=their_comps
                        , allow_null = auth.user_is_global_admin(), null_text="&lt;All&gt;"
                    )
                row += field("checkbox", "admin", comp=u[3], user=u[0], value=checked, extra=extra)
            ## Disable ##
            row += field("submit", "disable", comp=u[3], user=u[0],value="Disable")
            ## Delete ##
            row += field("submit", "delete", comp=u[3], user=u[0],value="Delete")
            rows.append(row)
        rows=html.tr(rows)

        if len(users):
            table = html.table( html.thead(
                html.tr( [
                html.th("Username")
                + html.th("Full name")
                + company_th
                + html.th("Email")
                + html.th("Admin")
                + html.th("Disable")
                + html.th("Delete")
                ] )
                ) + rows )
            return table
        else:
            return "No users"


    @expose
    @require()
    def admin_user(self):
        """Page to manage clients"""
        lstatus = auth.login_status()
        username = lstatus[0]
        company_name = lstatus[2]
        company_fullname = lstatus[3]
        if auth.user_is_any_admin(username):
            comps = auth.get_user_admin_companies()
            # Quick hack to bypass extended logic for simple admins
            if not auth.user_is_multi_admin():
                tables = self.admin_user_table((company_name, company_fullname), comps)
            else:
                tables =''
                if auth.user_is_global_admin():
                    tables = html.h2(html.i("No company")) + self.admin_user_table((None, "No company"), comps)
                for c in comps:
                    tab_type = "Company: "
                    tables += html.h2("%s%s"%(tab_type, html.i(c[1]))) + self.admin_user_table(c, comps)
                if auth.user_is_global_admin():
                    company_fullname = html.i("Global")

            if company_fullname is None:
                company_fullname = html.i("no company")
            return page.page("User Admin",
                html.h1("User Admin (%s)" % company_fullname)
                + tables)
        else:
            # If a non-admin tries to go to the admin page, redirect to the user page rather than cause a 403
            raise cherrypy.HTTPRedirect("user")

    @expose
    @require()
    def admin(self):
        # TODO: Tasks:
        # * Create/delete a new customer (companies table)
        # * Create/delete a new user (users table)
        # * Create/delete a new share (shares table)
        #lstatus = auth.login_status()
        #username = lstatus[0]
        #company_name = lstatus[2]
        #company_fullname = lstatus[3]
        if not auth.user_is_any_admin():
            raise cherrypy.HTTPRedirect("user")

        links = []
        links.append(html.a("Create new user", att='href="new_user"'))
        links.append(html.a("Manage existing users", att='href="admin_user"'))
        # Only global admins can create new customers and shares
        if auth.user_is_global_admin():
            links.append(html.a("Create new customer", att='href="new_cust"'))
            links.append(html.a("Create new share", att='href="new_share"'))
        
        return page.page("Admin"
            , html.h1("Admin")
            + html.ul(html.li([html.h2(x) for x in links]))
            )

    @expose
    @require()
    def new_user(self, uname=None, fname=None, passwd=None, comp=None, email=None, is_admin=None, admin_comps=None):
        lstatus = auth.login_status()
        username = lstatus[0]
        company_name = lstatus[2]
        company_fullname = lstatus[3]
        if not auth.user_is_any_admin(username):
            raise cherrypy.HTTPRedirect("user")

        if isinstance(admin_comps, basestring):
            admin_comps = [admin_comps]
        if comp == "NULL":
            comp = None

        is_admin = (is_admin == 'on')

        errors = []
        if validation.user_exists(uname):
            errors.append("The user '%s' already exists." % uname)
        if uname is not None and not uname:
            errors.append("You must enter a username.")
        if fname is not None and not fname:
            errors.append("You must enter a full name for the user.")
        if passwd is not None and not passwd:
            errors.append("You must enter a password for the user.")
        # if not email:
        #     errors.append("You must enter an email address.")
        if comp is not None and comp != "NULL" and not validation.company_exists(comp):
            errors.append("The company you selected does not exist.")
        if is_admin and admin_comps:
            # This is pretty horrible. '+ [True]' is needed for reduce() to not complain about an empty list.
            # Having any() and all() from Python 2.5 would be awesome.
            if not reduce(lambda x,y: x or y, [validation.company_exists(x) for x in admin_comps if x != "NULL"] + [True] ):
                errors.append("One or more of the companies you selected for administration does not exist.")
            # Make sure that POST spoofing can't be abused to allow users to create admins in other companies
            if not reduce(lambda x,y: x and y, [auth.user_is_admin(company=x) for x in admin_comps]):
                errors.append("You have selected a company for which you don't have administration rights.")
        if None in [uname, fname, passwd, is_admin, admin_comps] or len(errors):
            uname_val = fname_val = passwd_val = comp_val = email_val = admin_val = ""
            if uname:
                uname_val = ' value="%s"' % uname
            if fname:
                fname_val = ' value="%s"' % fname
            # # TODO: This needs more sensible security.
            # if passwd:
            #     passwd_val = ' value="%s"' % passwd
            if comp:
                comp_val = ' value="%s"' % comp
            if email:
                email_val = ' value="%s"' % email
            if is_admin:
                admin_val = ' checked'
            contents = [
                "Username" + html.br()
                + html.input(att='type="text" name="uname"' + uname_val)
                , "Full name" + html.br()
                + html.input(att='type="text" name="fname"' + fname_val)
                , "Password" + html.br()
                + html.input(att='type="password" name="passwd"' + passwd_val)
            ]
            admin_label = ''
            comps = auth.get_user_admin_companies()
            # Allow multi-company admins to create new admins for those companies
            if auth.user_is_multi_admin():
                admin_comp_name = 'Admin'
                if auth.user_is_global_admin():
                    allow_null = True
                else:
                    allow_null = False
                contents.extend([
                    "Company" + html.br()
                    + self.company_combobox("comp", comps, allow_null=allow_null)
                ])
                admin_label = "Admin for:" + html.br() \
                    + self.company_combobox("admin_comps", comps, selected=admin_comps, multi=True, null_text="&lt;All&gt;", allow_null=allow_null)
            else:
                admin_comp_name = "Admin for %s:" % comps[0][1] 
            contents.extend([
                "Email (optional)" + html.br()
                + html.input(att='type="text" name="email"' + email_val)
                , admin_comp_name + html.input(att='type="checkbox" name="is_admin"' + admin_val)
            ])
            if admin_label:
                contents.append(admin_label)

            return page.page("New user"
                , html.h1("Create new user")
                # TODO: Make this look more like an error
                + html.ul(
                    html.li(errors)
                )
                + html.form(
                    html.ul(
                        html.li(contents)
                    )
                    + html.input(att='type="submit" value="Submit"')
                    , att='method="POST"'
                )
            )
        else:
            try:
                # Python 2.5 and above
                import hashlib
                passwd = hashlib.md5(passwd).hexdigest()
            except ImportError:
                # Python 2.4
                import md5
                passwd = md5.new(passwd).hexdigest()
            db.do("insert into all_users (username, full_name, hashed_password) \
                values (%(uname)s, %(fname)s, %(passwd)s)", vars())
            if comp:
                db.do("update all_users set company_name = %(comp)s where username = %(uname)s", vars())
            if email:
                db.do("update all_users set email = %(comp)s where username = %(email)s", vars())
            if is_admin:
                if not admin_comps:
                    admin_comps = [comp]
                if "NULL" in admin_comps:
                    db.do("insert into admins (username, company_name) values (%(uname)s, null)", vars())
                else:
                    for comp in admin_comps:
                        db.do("insert into admins (username, company_name) values (%(uname)s, %(comp)s)", vars())
            # TODO: Give notification of success
            db.commit()
            raise cherrypy.HTTPRedirect("admin_user")

    @expose
    @require()
    def new_share(self, name=None, company=None):
        lstatus = auth.login_status()
        username = lstatus[0]
        company_name = lstatus[2]
        company_fullname = lstatus[3]
        # Only global admins can create new shares.
        if not auth.user_is_global_admin(username):
            raise cherrypy.HTTPRedirect("user")

        errors = []
        if name is not None and not name:
           errors.append("You must specify a share name.")
        elif validation.share_exists(name):
            errors.append("The share '%s' already exists." % name)
        if validation.company_exists(company) == False:
            errors.append("The company you selected does not exist.")
        if None in [name, company] or len(errors):
            comps = db.get("select name, long_name from companies")
            if name:
                val = ' value="%s"' % name
            else:
                val = ''
            contents = [
                "Share name" + html.br()
                + html.input(att='type="text" name="name"' + val)
                , "Company" + html.br()
                + self.company_combobox("company", comps, selected=company, allow_null=False)
            ]

            return page.page("New share"
                , html.h1("Create new share")
                # TODO: Make this look more like an error
                + html.ul(
                    html.li(errors)
                )
                + html.form(
                    html.ul(
                        html.li(contents)
                    )
                    + html.input(att='type="submit" value="Submit"')
                    , att='method="POST"'
                )
            )
        else:
            db.do("insert into all_shares (name, company_name) values (%(name)s, %(company)s)", vars())
            # TODO: Give notification of success
            db.commit()
            raise cherrypy.HTTPRedirect("admin")
        

    @expose
    @require()
    def new_cust(self, sname=None, lname=None, email=None):
        lstatus = auth.login_status()
        username = lstatus[0]
        company_name = lstatus[2]
        company_fullname = lstatus[3]
        if not auth.user_is_global_admin(username):
            raise cherrypy.HTTPRedirect("user")

        errors = []
        # TODO: replace reduce() here with all() if upgraded to Python 2.5
        if None not in [sname, lname, email] and \
                not reduce(lambda x,y: bool(x and y), [sname, lname, email]):
            errors.append("You must specify all fields.")
        if validation.company_exists(sname):
            errors.append("The company '%s' already exists." % sname)
        # TODO: Rework this to allow for fully validating the input
        if None in [sname, lname, email] or len(errors):
            if sname:
                comp_val = ' value="%s"' % sname
            else:
                comp_val = ''
            if lname:
                full_val = ' value="%s"' % lname
            else:
                full_val = ''
            if email:
                mail_val = ' value="%s"' % email
            else:
                mail_val = ''
            contents = [
                "Company ID" + html.br()
                + html.input(att='type="text" name="sname"' + comp_val)
                , "Full company name" + html.br()
                + html.input(att='type="text" name="lname"' + full_val)
                , "Email" + html.br()
                + html.input(att='type="text" name="email"' + mail_val)
            ]

            return page.page("New customer"
                , html.h1("Create new customer")
                # TODO: Make this look more like an error
                + html.ul(
                    html.li(errors)
                )
                + html.form(
                    html.ul(
                        html.li(contents)
                    )
                    + html.input(att='type="submit" value="Submit"')
                    , att='method="POST"'
                )
            )
        else:
            db.do("insert into all_companies (name, long_name, email) values (%(sname)s, %(lname)s, %(email)s)", vars())
            # TODO: Give notification of success
            db.commit()
            raise cherrypy.HTTPRedirect("admin_user")

    @expose
    @require()
    def admin_confirm(self, **keyw):
        lstatus = auth.login_status()
        username = lstatus[0]
        # Get the request instructions from the form field name
        if "value" not in keyw or keyw["value"] == "NULL":
            keyw["value"] = None
        if "extra" not in keyw:
            extra = False
        elif keyw["extra"] == "NULL":
            extra = None
        else:
            extra = keyw["extra"]
        comm, comp, user, value = tuple([ keyw[x] for x in ("comm", "comp", "user", "value") ])
        if comp == "":
            comp = None
        if auth.user_is_admin(company=comp):
            hit_admin = False
            warn = ""
            for each in keyw:
                value = keyw[each]
            args = {"user": user, "comp": comp, "comm": comm, "extra": extra }

            return page.page(
                "Flibble"
                , warn
                + html.ul(
                    html.li(
                        [ "%s: %s"%(x,args[x]) for x in args ]
                    )
                )
            )
        else:
            # If a non-admin tries to go to the admin page, redirect to the user page rather than cause a 403
            raise cherrypy.HTTPRedirect("user")

    @expose
    @require()
    def password(self, old_password=None, new_password1=None, new_password2=None):
        error_message = ""
        lstatus = auth.login_status()
        username = lstatus[0]

        password_form = html.form(
            html.table(
                html.tbody(
                    html.tr([
                            html.th("Old Password:") + html.td(html.input(att='type="password" name="old_password"')),
                            html.th("New Password:") + html.td(html.input(att='type="password" name="new_password1"')),
                            html.th("New Password (again):") + html.td(html.input(att='type="password" name="new_password2"')),
                            html.td(html.input(att='type="submit" value="Change Password"'), att='colspan="2"')
                        ]
                    )
                ),
                att='class="borderless"'),
            att='name="user" method="post" action="/backup/password"'
        ) + html.script('document.getElementsByName("old_password")[0].focus();', att='language="javascript"')

        error_message = ""
        info_message = ""

        if old_password is None and new_password1 is None and new_password2 is None:
            pass
        elif old_password is None or new_password1 is None or new_password2 is None:
            error_message = "Not all passwords supplied."
        elif new_password1 != new_password2:
            error_message = "New passwords do not match."
        elif len(new_password1) < 6:
            error_message = "New password must be at least six characters long."
        else:
            auth_check = auth.check_credentials(username, old_password)
            if auth_check[0] is None:
                # All good. Set the new password.
                auth.reset_password(username, new_password1)
                info_message = "Password successfully changed."
            else:
                error_message = "Old password is incorrect."

        if len(info_message) > 0:
            info_message = html.p(info_message)
        if len(error_message) > 0:
            error_message = html.p(html.span(error_message, att='class="error_message"'))

        return page.page("Change Password",
            html.h1("Change Password")
            + info_message
            + error_message
            + password_form)

    @expose
    @require()
    def json(self, **kwargs):
        # Whatever happens here, we return plaintext JSON.
        cherrypy.response.headers['Content-Type'] = "text/plain"

        company_name = cherrypy.session.get(auth.COMPANY_NAME)

        if 'action' in kwargs:
            action = kwargs['action']

            # We expect a call with share=?, path=? and action=remove/include.
            # share is the name of a share.
            # path is of the form "path:/2009-01-19T12:24:49Z/runaway.txt",
            # representing a path within a share.
            #
            # Obviously the user identity defines the company.
            if not ('path' in kwargs and 'share' in kwargs):
                return simplejson.dumps([False, None, "action, path and share all required."])

            path = re.sub('^path:', '', kwargs['path'])
            share_name = kwargs['share']

            # Make the file_spec we need.
            file_spec = make_file_spec(company_name, share_name, path)

            if not action in ('include', 'remove'):
                return simplejson.dumps([False, None, "Invalid action: %s" % ( action )])
            
            rs = restore_spec.RestoreSpec()
            message = ""
            if action == "include":
                if not rs.is_included(file_spec):
                    rs.include(file_spec)
                    message = "Included %s (%s)" % ( file_spec.name, filesize_exp(file_spec.acquire_disk_usage()) )
                # Doesn't matter if it's already included - we just
                # act in the same way if it'd just been successfully
                # included.
            elif action == "remove":
                if rs.is_included(file_spec):
                    rs.remove(file_spec)
                    message = "Removed %s (%s)" % ( file_spec.name, filesize_exp(file_spec.acquire_disk_usage()) )

            # The information returned in the second spot should
            # just be two numbers and a string:
            # * the current number of selected files/dirs
            # * the running-total du_size, and
            # * the running-total du_size as a string expression.
            du_exp = filesize_exp(rs.disk_usage_running_total)
            message += "<br/>Running total: %s" % ( du_exp )
            return simplejson.dumps([True, [len(rs.include_set.keys()), rs.disk_usage_running_total, du_exp], message]) 

        # Returns:
        # * a true/false for success/failure,
        # * a data structure of information iff success,
        # * a message string (error message iff failure).
        return simplejson.dumps([False, None, ""])

# Config.

zbm_config = {
    'global' : {
        # Explicitly set this to False for deployed apps.
        'engine.autoreload_on': False,

        'server.socket_host': '0.0.0.0',
        'server.socket_port': 8008,
        'server.thread_pool': 50,

        # To set data for the current session, use
        # cherrypy.session['fieldname'] = 'fieldvalue'.
        # To get data use cherrypy.session.get('fieldname').
        'tools.sessions.on' : True,
        'tools.sessions.storage_type' : 'file',
        'tools.sessions.storage_path' : os.path.join(os.path.abspath('.'), "sessions"),
        'tools.sessions.timeout' : 30, # 30 minutes

        'tools.auth.on' : True
    }
}

app_config = {
    'global' : {
        'tools.caching.on' : False,
        'tools.staticdir.root' : os.path.join(os.path.abspath('.'), "static")
    },

    # Define the web-app's favicon.
    '/favicon.ico' : {
        'tools.staticfile.on' : True,
        'tools.staticfile.filename' : os.path.join(os.path.abspath('.'), "static/zbm.ico")
    }
}

######################################################################
## 3.0-specific syntax.

# Check the session storage path exists.
storage_path = zbm_config['global']['tools.sessions.storage_path']
if not os.path.isdir(storage_path):
    print "Session storage path %s does not exist!\nBailing out." % ( storage_path )
    sys.exit(1)

# Tell CherryPy to call the db module's "connect" for each thread,
# when it starts up.
cherrypy.engine.subscribe('start_thread', db.connect)

cherrypy.config.update(zbm_config)
cherrypy.quickstart(ZfsBackupManager(), script_name="/backup", config=app_config)

######################################################################
## 3.1-specific syntax.
#cherrypy.config.update(zbm_config)
#cherrypy.tree.mount(ZfsBackupManager(), '/', app_config)
#cherrypy.engine.start()
#cherrypy.engine.block()

