#!/usr/bin/python

import debug
import cherrypy
from cherrypy import expose, tools, url

import sys
import os
import time
from datetime import datetime, timedelta
import timediff
import string
import re
import simplejson

import cgi
import html
import auth
import page

import chroot

# Simple database-access functionality.
import db

# ZBM config module.
import zbm_cfg as cfg

# The authentication module.
from auth import AuthController, require, member_of, name_is

# The restore handler.
import restore_spec

# Filesystem-browsing functionality.
import browse

local_dir = os.path.join(os.getcwd(), os.path.dirname(__file__))

# File size stuff.
file_size_class = [
    (1024, 'B'),
    (1024**2, 'KB'),
    (1024**3, 'MB'),
    (1024**4, 'GB'),
    (1024**5, 'TB')
]

def filesize_exp(size):
    s = file_size_class[0]
    if size < s[0]:
        return str(size)

    s = file_size_class[-1]
    if not size < s[0]:
        return "%0.1f%s" % ( float(size)/(s[0]/1024), s[1] )

    for s in file_size_class[1:]:
        if size < s[0]:
            return "%0.1f%s" % ( float(size)/(s[0]/1024), s[1] )

# Given size in bytes, return suitable HTML expression.
def filesize_html(size):
    return html.span(filesize_exp(size), att='value="%s"' % ( size ))

def split_path(pathname):
    if pathname == '/':
        return ['/']
    if pathname == '':
        return []
    (basepath, basename) = os.path.split(pathname)

    sp = split_path(basepath)
    if basename != '':
        sp.append(basename)
    return sp


def pathname_dirlink(share, pathname, highlight_share=False, show_all_shares_link=True):
    """
    Takes a path string and return a string where each directory
    name is a link to that directory, eg.:

    "/etc/" => '<a href="/browse?path=/">&nbsp;/</a><a href="/browse?path=/etc">etc/</a>'

    The trailing / should be included in the link text.

    Note that there is no validation that it's a real path.
    """
    escaped_share = cgi.escape(share, quote=True)
    all_shares_link = ""
    if show_all_shares_link:
        all_shares_link = html.a("shares/", att='class="dirlink" href="/browse"')
    if pathname == '/':
        share_link = html.a(escaped_share+"/", att='id="share_name" name="%s" class="dirlink" href="/browse?share=%s&amp;path=/"' % ( escaped_share, escaped_share ))
        if highlight_share:
            return all_shares_link + html.b(share_link)
        return all_shares_link + share_link

    (basepath, basename) = os.path.split(pathname)
    name_html = html.a(basename + "/", att='class="dirlink" href="/browse?share=%s&amp;path=%s"' % ( escaped_share, cgi.escape(pathname, quote=True) ))
    if basepath == '':
        return name_html
    return pathname_dirlink(share, basepath, highlight_share=highlight_share, show_all_shares_link=show_all_shares_link) + name_html

def get_extension(filename):
    filename_ext = ''
    m = re.search(r'^[^.].*\.([^.]+)$', filename)
    if m:
        filename_ext = string.lower(m.group(1))
    return filename_ext

def tr_filespec(rs, file_spec, revolver=None):
    f = file_spec

    tr_attr = ""
    if not revolver is None:
        tr_attr = "class='%s'" % ( revolver.state() )

    lmt = time.localtime(f.mtime)
    time_exp = time.strftime('%Y-%m-%d %H:%M:%S', lmt)

    filename_ext = get_extension(f.name)

    now = datetime.now()
    mtime_dt = datetime(*lmt[:6])
    age_exp = ''
    if mtime_dt < now:
        age_exp = str(timediff.show(now - mtime_dt))

    escaped_path = cgi.escape(f.path, quote=True)
    is_checked = ""
    if rs.is_included(f):
        is_checked = " checked"
        if not rs.is_directly_included(f):
            is_checked += " disabled"

    checkbox_attr = 'class="zbm_select" name="path:%s" type="checkbox"%s' % ( escaped_path, is_checked )
    return html.tr(
        html.td([
            html.input(att=checkbox_attr),
            f.type,
            filesize_html(f.size),
            f.display,
            filename_ext,
            time_exp,
            age_exp]), att=tr_attr)

def can_access_parent(path):
    return not ( path == '/' or path == '' )

class EmptyRevolverError(Exception):
    def __init__(self, value):
        self.value = value
    def __str__(self):
        return repr(self.value)

# Rotates through the values of a given array/tuple.
class Revolver:
    def __init__(self, collection):
        if len(collection) == 0:
            raise EmptyRevolverError("Empty collection supplied to Revolver.")
        self._collection = collection
        self._index = 0

    def state(self):
        rv = self._collection[self._index]
        incremented = self._index + 1
        if incremented < len(self._collection):
            self._index = incremented
        else:
            self._index = 0
        return rv

def dir_box(rs, share, chrooted_path):
    dir_filespec = browse.FileSpec(chrooted_path, share)
    escaped_share_plus_path = cgi.escape(dir_filespec.share_plus_path, quote=True)
    dir_contents = browse.get_dir_contents(chrooted_path, share)

    def all_directly_included(rs, fs):
        for f in fs:
            if not rs.is_directly_included(f):
                return False
        return True

    # Check to see if all dir_contents are (directly) included.
    select_all_extra = ""
    if rs.is_included(dir_filespec):
        select_all_extra = " disabled checked"
    elif len(dir_contents) > 1 and all_directly_included(rs, dir_contents[1:]):
        select_all_extra = " checked"

    select_all_checkbox = html.input(att='id="select_all" name="spath:%s" title="Select/deselect all" type="checkbox"%s' % ( escaped_share_plus_path, select_all_extra ))
    dir_header = html.thead(html.tr(html.th([select_all_checkbox, 'Type', 'Size', 'Name', 'Ext', 'Last Modified', 'Age'])))

    parent_dir_html = ""
    if not dir_contents[0] is None:
        parent_dir_html = html.p(dir_contents[0].display)

    revolver = Revolver(('row_odd', 'row_even'))

    dir_contents_html = html.tbody(string.join(map(lambda fs: tr_filespec(rs, fs, revolver), dir_contents[1:])))
    return html.div(parent_dir_html + html.table(dir_header + dir_contents_html, att='class="browsedir tablesorter"'), att='class="browsedir"')

def make_file_spec(company_name, share_name, path):
    """ Returns a FileSpec from a company_name, share_name, path. """
    sp = chroot.build_share_path(company_name, share_name)
    mychroot = chroot.Chroot(sp)
    return browse.FileSpec(mychroot.chrooted_path(path), share_name)


class ZfsBackupManager:
    auth = AuthController()

    def __init__(self):
        # If an exception is raised here, let it go.
        pass

    @expose
    @require()
    def index(self):
        return self.show()

    @expose
    @require()
    def show(self, restore_id=None, message=None):
        company_name = cherrypy.session.get(auth.COMPANY_NAME)

        rs = None
        if restore_id is None:
            rs = restore_spec.RestoreSpec()
            restore_id = rs.restore_id
        else:
            restore_id = int(restore_id)
            rs = restore_spec.RestoreSpec(restore_id)

        ifs_header = html.thead(html.tr(html.th(['', 'Size', 'Name'])))
        # Assemble simple list of the files in given restore.
        revolver = Revolver(('row_odd', 'row_even'));

        def make_checkbox_input(fs):
            escaped_share_plus_path = cgi.escape(fs.share_plus_path, quote=True)
            # Note the prefix of the name attribute's value is
            # "spath", not "path" - because it has to be a
            # share_plus_path expression.
            checkbox_attr = 'class="zbm_select" name="spath:%s" type="checkbox" checked' % ( escaped_share_plus_path )
            return html.input(att=checkbox_attr)

        def ifs_to_row(file_spec):
            """ Returns a HTML link for displaying a share-plus-path expression. """
            tr_attr = "class='%s'" % ( revolver.state() )
            share_name = file_spec.share

            # The file_path we want to use is the *parent* of the
            # file_spec above.
            parent_file_spec = file_spec.get_parent()
            if parent_file_spec is None:
                # This technically should not happen, as we don't
                # provide a way to select an entire share.
                parent_file_spec = file_spec

            parent_file_path = parent_file_spec.path

            escaped_share_name = cgi.escape(share_name, quote=True)
            file_spec_size_span = filesize_html(file_spec.acquire_disk_usage())
            return html.tr(html.td([make_checkbox_input(file_spec), file_spec_size_span,
                    html.span(pathname_dirlink(share_name, parent_file_path, highlight_share=True) + cgi.escape(file_spec.basename, quote=True), att='value="%s"' % ( file_spec.share_plus_path )) ]), att=tr_attr)

        included_filespecs = rs.include_set.values()

        restore_display = ""
        if len(included_filespecs) > 0:
            form = html.form(
                html.table(
                    html.tbody(
                        html.tr(
                            html.td([
                                html.input(att='name="cancel_restore" type="submit" value="Cancel Restore" title="Wipe out your current set of restore files."'),
                                html.input(att='name="create_tarball" type="submit" value="Create Tarball" title="Create a restore tarball."'),
                                html.input(att='name="create_zipfile" type="submit" value="Create Zipfile" title="Create a restore zipfile."')
                            ]))),
                    att='class="borderless restore_action"'),
                att='name="restore" method="post" action="/action"')

            # Sort them for a more orderly display.
            included_filespecs.sort(lambda a, b: cmp(a.share_plus_path, b.share_plus_path))
            restore_path_rows = string.join([ ifs_to_row(ifs) for ifs in included_filespecs ])
            restore_display = form + html.table(ifs_header + html.tbody(restore_path_rows), att='style="margin-left:10px" class="tablesorter restore_display"')
        else:
            restore_display = html.p("Current restore is empty.")

        if message is None:
            message = ""
        else:
            message = html.p(message)

        # Okay, let's show some actual *details* about the current
        # restore.
        return page.page("ZBM - Current Restore",
            html.h1("Current Restore")
            + message
            + html.p("Running total size is %s." % ( html.span(filesize_exp(rs.disk_usage_running_total), att='class="running_total_size"') ))
            + restore_display 
            )

    @expose
    @require()
    def browse(self, share=None, path="/"):

        # Info from session.
        company_name = cherrypy.session.get(auth.COMPANY_NAME)

        # Okay, how to handle share....?
        if share is None:
            # We must return a list of available shares.
            available_shares = [ s[0] for s in db.get("select name from shares where company_name = %(company_name)s", vars()) ]
            links = [ html.a(s, att='href="/browse?share=%s"' % ( cgi.escape(s, quote=True) )) for s in available_shares ]

            return page.page("ZBM - Select Share",
                html.h1("Select Share")
                + html.ul(html.li(links)))

        rs = restore_spec.RestoreSpec()
        error_message = ""
        dir_box_html = ""
        try:
            # Now we use the company and share names to construct the chroot.
            sp = chroot.build_share_path(company_name, share)

            mychroot = chroot.Chroot(sp)
            chrooted_path = mychroot.chrooted_path(path)
            # Supply the share name as well as the chrooted path.
            dir_box_html = dir_box(rs, share, chrooted_path)
        except chroot.BadChrootPath, e:
            error_message = html.p(html.span(str(e), att='class="error_message"'))

        return page.page("ZBM - Browse Share",
            html.h1(pathname_dirlink(share, path))
            + error_message
            + dir_box_html)

    static = tools.staticdir.handler(section="/static",
            dir=os.path.join(local_dir, "static"))

    @expose
    @require()
    def action(self, **kwargs):
        rs = restore_spec.RestoreSpec()
        if 'cancel_restore' in kwargs:
            restore_spec.cancel_current_restore()
            return self.show(message="Restore cancelled.")
        if 'create_tarball' in kwargs:
            ( result, partname ) = restore_spec.create_restore_file(rs, "tar")
            if result:
                message = "Successfully created tarball: %s" % ( html.a(partname, att='href="%s/%s"' % ( cfg.RESTORE_BASE_URL, cgi.escape(partname, quote=True) )) )
            else:
                message = "Failed to create tarball: %s" % ( partname )
            return self.show(message=message)
        if 'create_zipfile' in kwargs:
            ( result, partname ) = restore_spec.create_restore_file(rs, "zip")
            if result:
                message = "Successfully created zipfile: %s" % ( html.a(partname, att='href="%s/%s"' % ( cfg.RESTORE_BASE_URL, cgi.escape(partname, quote=True) )) )
            else:
                message = "Failed to create zipfile: %s" % ( partname )
            return self.show(message=message)

        return self.show()

    @expose
    @require()
    def user(self, old_password=None, new_password1=None, new_password2=None):
        error_message = ""
        lstatus = auth.login_status()
        username = lstatus[0]

        password_form = html.form(
            html.table(
                html.tbody(
                    html.tr([
                            html.th("Old Password:") + html.td(html.input(att='type="password" name="old_password"')),
                            html.th("New Password:") + html.td(html.input(att='type="password" name="new_password1"')),
                            html.th("New Password (again):") + html.td(html.input(att='type="password" name="new_password2"')),
                            html.td(html.input(att='type="submit" value="Login"'), att='colspan="2"')
                        ]
                    )
                ),
                att='class="borderless"'),
            att='name="user" method="post" action="/user"'
        ) + html.script('document.getElementsByName("old_password")[0].focus();', att='language="javascript"')

        error_message = ""
        info_message = ""

        if old_password is None and new_password1 is None and new_password2 is None:
            pass
        elif old_password is None or new_password1 is None or new_password2 is None:
            error_message = "Not all passwords supplied."
        elif new_password1 != new_password2:
            error_message = "New passwords do not match."
        elif len(new_password1) < 6:
            error_message = "New password must be at least six characters long."
        else:
            auth_check = auth.check_credentials(username, old_password)
            if auth_check[0] is None:
                # All good. Set the new password.
                auth.reset_password(username, new_password1)
                info_message = "Password successfully changed."
            else:
                error_message = "Old password is incorrect."

        if len(info_message) > 0:
            info_message = html.p(info_message)
        if len(error_message) > 0:
            error_message = html.p(html.span(error_message, att='class="error_message"'))

        return page.page("ZBM - Change Password",
            html.h1("Change Password")
            + info_message
            + error_message
            + password_form)

    @expose
    @require()
    def json(self, **kwargs):
        # Whatever happens here, we return plaintext JSON.
        cherrypy.response.headers['Content-Type'] = "text/plain"

        company_name = cherrypy.session.get(auth.COMPANY_NAME)

        if 'action' in kwargs:
            action = kwargs['action']

            # We expect a call with share=?, path=? and action=remove/include.
            # share is the name of a share.
            # path is of the form "path:/2009-01-19T12:24:49Z/runaway.txt",
            # representing a path within a share.
            #
            # Obviously the user identity defines the company.
            if not ('path' in kwargs and 'share' in kwargs):
                return simplejson.dumps([False, None, "action, path and share all required."])

            path = re.sub('^path:', '', kwargs['path'])
            share_name = kwargs['share']

            # Make the file_spec we need.
            file_spec = make_file_spec(company_name, share_name, path)

            if not action in ('include', 'remove'):
                return simplejson.dumps([False, None, "Invalid action: %s" % ( action )])
            
            rs = restore_spec.RestoreSpec()
            message = ""
            if action == "include":
                if not rs.is_included(file_spec):
                    rs.include(file_spec)
                    message = "Included %s (%s)" % ( file_spec.name, filesize_exp(file_spec.acquire_disk_usage()) )
                # Doesn't matter if it's already included - we just
                # act in the same way if it'd just been successfully
                # included.
            elif action == "remove":
                if rs.is_included(file_spec):
                    rs.remove(file_spec)
                    message = "Removed %s (%s)" % ( file_spec.name, filesize_exp(file_spec.acquire_disk_usage()) )

            # The information returned in the second spot should
            # just be two numbers and a string:
            # * the current number of selected files/dirs
            # * the running-total du_size, and
            # * the running-total du_size as a string expression.
            du_exp = filesize_exp(rs.disk_usage_running_total)
            message += "<br/>Running total: %s" % ( du_exp )
            return simplejson.dumps([True, [len(rs.include_set.keys()), rs.disk_usage_running_total, du_exp], message]) 

        # Returns:
        # * a true/false for success/failure,
        # * a data structure of information iff success,
        # * a message string (error message iff failure).
        return simplejson.dumps([False, None, ""])

# Config.

zbm_config = {
    'global' : {
        'server.socket_host': '0.0.0.0',
        'server.socket_port': 8008,
        'server.thread_pool': 10,

        # To set data for the current session, use
        # cherrypy.session['fieldname'] = 'fieldvalue'.
        # To get data use cherrypy.session.get('fieldname').
        'tools.sessions.on' : True,
        'tools.sessions.storage_type' : 'file',
        'tools.sessions.storage_path' : os.path.join(os.path.abspath('.'), "sessions"),
        'tools.sessions.timeout' : 30, # 30 minutes

        'tools.auth.on' : True
    }
}

app_config = {
    'global' : {
        'tools.caching.on' : False,
        'tools.staticdir.root' : os.path.join(os.path.abspath('.'), "static")
    },

    # Define the web-app's favicon.
    '/favicon.ico' : {
        'tools.staticfile.on' : True,
        'tools.staticfile.filename' : os.path.join(os.path.abspath('.'), "static/zbm.ico")
    }
}

######################################################################
## 3.0-specific syntax.

# Check the session storage path exists.
storage_path = zbm_config['global']['tools.sessions.storage_path']
if not os.path.isdir(storage_path):
    print "Session storage path %s does not exist!\nBailing out." % ( storage_path )
    sys.exit(1)

# Tell CherryPy to call the db module's "connect" for each thread,
# when it starts up.
cherrypy.engine.subscribe('start_thread', db.connect)

cherrypy.config.update(zbm_config)
cherrypy.quickstart(ZfsBackupManager(), config=app_config)

######################################################################
## 3.1-specific syntax.
#cherrypy.config.update(zbm_config)
#cherrypy.tree.mount(ZfsBackupManager(), '/', app_config)
#cherrypy.engine.start()
#cherrypy.engine.block()

